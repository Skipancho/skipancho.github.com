---
layout: single
title: "[Android(Kotlin)] 코루틴(Coroutine) 다시 공부하기 - 1 "
categories: 
    - Android(Kotlin)
tag:
    - [Android, Kotlin]

toc: true
toc_sticky: true
---

오늘 GlobalScope와 ViewModelScope의 차이가 무엇이냐는 질문에 대답하지 못하였다. 그냥 ViewModel에서는 ViewModelScope를 사용하고 나머지는 GlobalScope를 사용하는 무식한 방식으로 코루틴을 사용해오면서 왜? 라는 의문조차 가지지 않았다는 사실에 조금 충격...(알고보니 썩 좋은 사용법도 아니었다.) 그래서 다시 처음부터 공부해보기로 했다.

[kotlin 기초 - 3](https://skipancho.github.io/android(kotlin)/3/)에서 이어지는 내용으로 오늘은 키워드 중점으로 작성을 해볼까 한다.

# CoroutineScope
CoroutineScope는 코루틴의 scope를 정의하는 인터페이스로 코루틴 블록을 묶음으로 제어할 수 있는 단위이다. launch 또는 async를 사용해 만든 코루틴을 추적하고 언제든지 `scope.cancel()`를 통해 취소할 수 있게 한다.

## GlobalScope
싱글톤으로 만들어진 CoroutineScope의 한 종류로 앱의 생명주기와 함께 동작하기 때문에 별도의 생명 주기 관리가 필요없다. 앱 실행부터 종료까지 긴시간동안 실행되는 코루틴의 경우에 사용하는 것이 적합하다. 
[GlobalScope](https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-global-scope/index.html)에 따르면 GlobalScope는 섬세하므로(생명주기를 따르므로 취소나 예외처리가 복잡하다.) 실수로 리소스 또는 메모리 누수가 발생하기 쉽고 구조적 동시성의 원칙을 따르지 않으므로 느린 네트워크 등의 문제로 중단되거나 지연되는 경우 계속 작동하며 리소스를 소비한다.

```kotlin
fun loadConfiguration() {
    GlobalScope.launch {
        val config = fetchConfigFromServer() // network request
        updateConfiguration(config)
    }
}
```
위의 함수를 호출하면 GlobalScope에서 코루틴을 생성한다. GlobalScope는  취소나 완료를 기다리지 않고 백그라운드에서 작동하므로 네트워크가 느릴 경우 백그라운드에서 계속 대기하여 리소스를 소모한다.

이러한 GlobalScope를 가능한 제거하는 것을 권장한다. 

위와 같은 작업을 suspend로 포함시키는 것이 좋다.

```kotlin
suspend fun loadConfiguration() {
    val config = fetchConfigFromServer() // network request
    updateConfiguration(config)
}
```

`GlobalScope.launch`가 여러 작업을 동시에 시작하는 데 사용된 경우 coroutineScope로 그룹화한다.
```kotlin
// concurrently load configuration and data
suspend fun loadConfigurationAndData() {
    coroutineScope {
        launch { loadConfiguration() }
        launch { loadData() }
    }
}
```



**참고 문헌**

- [GlobalScope](https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-global-scope/index.html)

