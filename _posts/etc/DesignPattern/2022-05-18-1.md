---
layout: single
title: "[디자인 패턴(Design Pattern)] 디자인 패턴이란?"
categories: 
    - DesignPattern
tag:
    - 디자인 패턴

toc: true
toc_sticky: true
---

<br>

# 디자인 패턴이란?
- 모듈 간의 관계 및 인터페이스를 설계할 때 참조할 수 있는 전형적인 해결 방식 또는 예제
- 설계의 노하우를 재사용하기 좋게 규칙을 만들어 정리한 것
- 특정한 상황의 구조적 문제를 해결하는 방식
- '바퀴를 다시 발명하지 마라'라는 말과 같이 새로운 해결책을 구상하는 것보다 디자인 패턴을 참고해 적용하는 것이 더 효율적임

<br>

# GoF 디자인 패턴
1995년 GoF(Gang of Four)라고 불리는 Erich Gamma, Richard Helm, Ralph Johnson, John Vissides가 구체화한 디자인 패턴. 
소프트웨어 공학에서 가장 많이 사용되는 디자인 패턴으로 생성 패턴 5개, 구조 패턴 7개, 행위 패턴 11개로 이루어져 있다.


## 생성 패턴
클래스나 객체의 생성과 참조 과정을 정의하는 패턴이다. 생성 패턴에는 다음과 같은 디자인 패턴이 있다.
- 추상 팩토리(Abstract Factory) :
    + 구체적인 클래스에 의존하지 않고, 인터페이스를 통해 연관∙ 의존하는 객체들의 그룹으로 생성하여 추상적으로 표현
    + 연관된 서브 클래스를 묶어 한 번에 교체하는 것이 가능
- 빌더(Builder) :
    + 작게 분리된 인스턴스를 건축 하듯이 조합해 객체를 생성
    + 객체의 생성 과정과 표현 방법을 분리하여 동일한 객체 생성에서도 서로 다른 결과를 만들어 낼 수 있다.
- 팩토리 메소드(Factory Method) :
    + 객체 생성을 서브 클래스에서 처리하도록 분리하여 캡슐화 한 패턴
    + 상위 클래스에서 인터페이스만 정의하고 실제 생성은 서브 클래스가 담당
- 프로토타입(Prototype) :
    + 원본 객체를 복제하는 방법으로 객체를 생성하는 패턴
    + 일반적인 방법으로 객체를 생성하며, 비용이 큰 경우 주로 사용
- 싱글톤(Singleton) :
    + 하나의 객체를 생성하면 생성된 객체를 어디서든 참조할 수 있음
    + 단 여러 프로세스에서 동시에 참조는 불가능
    + 클래스 내에서 인스턴스가 하나뿐임을 보장, 불필요한 메모리 낭비 최소화

## 구조 패턴
구조가 복잡한 시스템을 개발하기 쉽도록 클래스나 객체들을 조합하여 더 큰 구조로 만드는 패턴이다. 구조 패턴에는 다음과 같은 디자인 패턴이 있다.
- 어댑터(Adapter) : 
    + 호환성이 없는 클래스들의 인터페이스를 다른 클래스가 이용할 수 있도록 변환해주는 패턴
    + 기존의 클래스를 이용하고 싶지만 인터페이스가 일치하지 않을 때 이용
- 브릿지(Bridge) :
    + 구현부에서 추상층을 분리하여, 서로가 독립적으로 확장할 수 있도록 구성한 패턴
    + 기능과 구현을 두 개의 별도 클래스로 구현
- 컴포지트(Composite) :
    + 여러 객체를 가진 복합 객체와 단일 객체를 구분 없이 다루고자 할 때 사용
    + 객체들을 트리 구조로 구성하여 디렉터리 안에 디렉터리가 있듯이 복합 객체 안에 복합 객체가 포함되는 구조를 구현할 수 있다.
- 데코레이터(Decorator) :
    + 객체 간의 결합을 통해 능동적으로 기능을 확장할 수 있음
    + 임의의 객체에 부가적인 기능을 추가하기 위해 다른 객체를 덧붙이는 방식으로 구현
- 퍼싸드(Facade) :
    + 복잡한 서브 클래스들을 피해 더 상위에 인터페이스를 구성함으로써 서브 클래스들의 기능을 간편하게 사용할 수 있음
    + 서브 클래스들 사이의 통합 인터페이스를 제공하는 Wrapper 객체가 필요
- 플라이웨이트(Flyweight) :
    + 인스턴스가 필요할 떄마다 매번 생성을 하지 않고 가능한 공유해서 사용하는 것으로 메모리를 절약
    + 다수의 유사 객체를 생성하거나 조작할 때 유용
- 프록시(Proxy) :
    + 접근이 어려운 객체와 여기에 연결하려는 객체 사이에서 인터페이스 역할을 수행
    + 네트워크 연결, 메모리의 대용량 객체로의 접근 등에 주로 이용

## 행위 패턴
클래스나 객체들이 서로 상호작용하는 방법이나 책임 분배 방법을 정의하는 패턴이다. 행위 패턴에는 다음과 같은 디자인 패턴이 있다.
- 책임 연쇄(Chain of Responsibility) :
    + 요청을 처리할 수 있는 객체가 둘 이상 존재하여 한 객체가 처리하지 못한다면 다음 객체로 넘어가는 형태
    + 요청을 처리하는 각 객체들이 Chain으로 묶여 있음
- 커맨드(Command) :
    + 요청을 객체의 형태로 캡슐화하여 재이용하거나 취소할 수 있도록 요청에 필요한 정보를 저장 또는 로그에 남김
    + 명령어들을 추상 클래스와 구체 클래스로 분리해 단순화
- 인터프리터(Interpreter) :
    + 언어에 문법 표현을 정의
    + SQL이나 통신 프로토콜 등을 개발할 때 사용
- 반복자(Iterator) :
    + 자료 구조와 같이 접근이 잦은 객체에 대해 동일한 인터페이스를 사용하도록 함
    + 내부 표현 방법의 노출 없이 순차적인 접근이 가능
- 중재자(Mediator) :
    + 수많은 객체들 간의 복잡한 상호작용(Interface)을 캡슐화하여 객체로 정의
    + 객체 사이의 의존성을 줄여 결합도 감소
- 메멘토(Memento) :
    + 특정 시점에서의 객체 내부 상태를 객체화하여 이후 요청에 따라 객체를 해당 지점의 상태로 되돌리는 기능을 제공
- 옵저버(Observer) :
    + 한 객체의 상태가 변화하면 객체에 상속되어 있는 다른 객체들에게 변화된 상태를 전달
    + 일대다의 의존성을 정의함
    + 주로 분산된 시스템 간에 이벤트를 생성∙발행(Publish)하고, 이를 수신(Subscribe)해야 할 때 사용
- 상태(State) :
    + 객체의 상태에 따라 동일한 동작을 다르게 처리해야 할 때 사용
    + 객체 상태를 캡슐화하고 이를 참조하는 방식
- 전략(Strategy) :
    + 동일한 계열의 알고리즘들을 개별적으로 캡슐화하여 상호 교환 할 수 있게 정의
    + 클라이언트는 독립적으로 원하는 알고리즘을 선택하여 사용 가능
    + 클라이언트에 영향 없이 알고리즘의 변경 가능
- 템플릿 메소드(Template Method) :
    + 상위 클래스에서 골격을 정의하고, 하위 클래스에서 세부 처리를 구체화하는 구조의 패턴
    + 유사한 서브 클래스를 묶어 공통된 내용을 상위 클래스에서 정의함으로 써 코드의 양을 줄이고 유지보수를 용이하게 해줌
- 방문자(Visitor) :
    + 각 클래스들의 데이터 구조에서 처리 기능을 분리하여 별도의 클래스로 구성
    + 분리된 처리 기능은 각 클래스를 방문(Visit)하여 수행




---
<br>
<br>
<br>


**참조 문헌**
- 김정준 외 4명, 「시나공 - 정보처리기사 실기」 