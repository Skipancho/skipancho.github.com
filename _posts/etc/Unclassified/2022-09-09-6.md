---
layout: single
title: "미분류 - 5주차 공부2"
categories: 
    - unclassified
tag:
    - [미분류]

toc: true
toc_sticky: true
---

<br>

아 솔직히 이건 뭔가 아직 어렵다.

# 객체지향 설계
객체지향 설계 원칙을 설명하기 전 다음의 두 용어를 정의한다.
- 결합도 : 의존의 정도
- 응집도 : 연관의 정도

결합도가 낮고 응집도가 높은 코드는 재사용성이 높아지고 수정이 최소화 되기 때문에 유지 보수에 용이해진다.

객체지향 설계 원칙(SOLID)는 다른 클래스간의 결합도를 낮추고 클래스 내부의 응집도를 높이기 위한 원칙이다.

객체지향 설계의 핵심은 다음의 3가지 이다.
- 협력 : 앱의 기능을 구현하기 위해 메시지를 주고받는 객체들 사이의 상호작용 
<br>(예 : 다른 객체의 메소드 호출)

- 책임 : 객체가 다른 객체와 협력하기 위해 수행하는 행동 <br>(예 : 다른 객체의 메소드를 호출하기위한 행위, 클래스 상태를 저장하는 변수 메소드 등)

- 역할 : 객체들이 협력 안에서 수행하는 책임들이 모여 객체가 수행하는 역할을 구성, 책임의 집합
<br>(예 : 상태를 저장할 변수나 메소드를 정의한 인터페이스)

## 객체지향 설계 원칙 (SOLID)
객체지향 설계를 위한 원칙은 다음의 5가지가 있다.

1. SRP (Single Responsibility Principle)
2. OCP (Open - Closed Principle)
3. LSP (Liskov Subsitution Principle)
4. ISP (Interface Segregation Principle)
5. DIP (Dependency Inversion Principle)

음... 하나씩 보자...

### SRP (Single Responsibility Principle) - 단일 책임 원칙
> 한 클래스는 단 하나의 변경 이유를 가져야한다.

간단히 말하면 하나의 클래스는 단 하나의 책임을 가져야 한다.
하나의 클래스가 여러개의 책임을 가지고 있다면 그 클래스는 각 책임마다 수정 사유가 발생할 수 있고 그로 인해 연쇄적으로 많은 코드를 수정해야한다. 책임의 개수가 많아질수록 책임 사이의 의존성이 높아지기 때문에 코드가 절차 지향적으로 변하는 문제를 발생시킬 수 있다.

### OCP (Open - Closed Principle) - 개방 폐쇄 원칙
> 소프트웨어개체(클래스, 모듈, 함수 등)는 확장에 대해 열려 있어야 하고, 수정에 대해서는 닫혀 있어야 한다.

기존 동작을 변경하지 않으면서 기능을 추가할 수 있도록 설계가 되어야 한다는 원칙이다.

### LSP (Liskov Subsitution Principle)
> 서브 타입은 언제나 자신의 기반 타입으로 교체할 수 있어야 한다.

- SubTyping : 타입 계층을 구성하기 위해 상속을 하는 경우
- Super 타입, Sub 타입
- 위반 예시 : Stack 과 Vector

### ISP (Interface Segregation Principle) - 인터페이스 분리 원칙
> 객체는 자신이 호출하지 않는 메소드에 의존하지 않아야 한다.

구현할 객체가 무의미한 메소드의 구현을 방지하기 위해 반드시 필요한 메소드만을 상속할 수 있도록 구현해야한다. 즉 인터페이스는 그 인터페이스를 사용하는 클라이언트 기준으로 분리해야 한다. 

### DIP (Dependency Inversion Principle) - 의존성 역전 원칙
> Depend on abstractions, not on concretions.

유연하고 재사용 가능한 설계를 위해 자주 변화하는 것에 의존하는 것 보다 변화하기 어려운 인터페이스나 추상 클래스를 의존하라는 원칙이다.

반려 동물의 집을 만들 때 삽살개가 살 집인지 풍산개가 살 집인지를 생각하는 것이 아니라 개가 살 집인지 고양이가 살 집인지를 생각해야한다 뭐 그런 느낌